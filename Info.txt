一、词法分析
    1、目前为止，词法分析的内容确实都快忘了！！这里的想法是先将输入的语句分隔开处理为二元式的格式
    2、
    int a;
    int b;
    int c;
    a = 2;
    b = 1;              //多位数赋值?
    if ( a > b )
    c = a + b;
    else
    c = a - b;
    不妨对以上语句进行分析发现，倘若使用RE对原始字符串进行分割可能会好一些
    3、思路是
        (1)首先将从文件中读取到的字符串以空格为标识符进行分割 -> 预处理阶段
        (2)接下来对得到的每一个字符串转换为byte[]进行处理
        (3)创造一个Word类来存储输入的字符，定义一些属性与变量
        (4)不妨使用LinkedList作为存储工具，将得到的所有字符按照一定的顺序构建出对应的链表(循环链表较为合适!)

    附：一些思考
    ① 由于引入正则匹配的形式，这也就意味着可以直接对一些类型定义(关键字)进行匹配
    ② 需要考虑的一些问题
        [1] 多位数为变量赋值的问题                             √
        [2] 变量的多位数定义问题                               √
        [3] 关于使用链表存储的问题，发现下标Index不存在也可以!
        [4] 注意！关键字中出现了float，这也就意味着可以定义小数，因此需要对'.'进行处理!
        [5] 这里不妨强制要求运算符左右都留有空格！ (dog^)
        [6] 未定义变量就直接使用的问题 -> 这里必须先定义变量才行，否则多字符变量会被拆解为单字符变量!
                                  ->  定义之后就可以通过查表的形式进行辨别
                                  -> 即在regWord中添加在符号表(想法是以HashMap形式实现)中查询
    4、分析语句中出现的各种符号的类型

    5、接下来对符号表进行构建
        -> 符号表中存储有变量(标识符)和常量(数字常数和字符常数)
            -> 这里需要做的就是将标识符实例化出来(想法是构建一个类),存放入HashMap中作为符号表
        -> 针对于这个类的构建: ① 需要有int、float私有属性，这里建议使用包装类实现         -> 再加上一个Word类作为私有属性(存储类型及种别等)
                            ② 若扫描到为关键字，则进入符号表的构建状态，创建类加入符号表中
                            ③ 针对于这些变量的定义，基本上为keyWord + letter + ; 组成
                            ④ 扫描词法分析初步形成的序列即可摘出这些定义

    6、遇到的问题:
      (1) == 并不能匹配!     正则匹配要接收返回值!
      (2) 针对重复定义问题: 使用IdentityHashMap作为符号表的时候会出现重复的情况，因为IdentityHashMap的key判断标准为若两者是不同的对象，
          哪怕使用String.equal()得到的结果为true，也可以被加入到其中.


二、语法分析
    1、难度断崖式增长!
    2、必须自动生成
       -> 首先对于从文件中读取的字符串，以换行符(\r\n)为界限进行划分为子字符串序列
       -> 对产生式进行分析 --> S → id = E;
       -> ① 以 ' → ' 为分隔符进行划分
          ② 将右部得到的语法变量加入到一个HashMap之中，Key值即为String类型的字符串，而Value值为由Key可以生成的字符序列(这里使用LinkedList存储)
             接下来还必须对得到的序列进行分析，以 ' ' 为界限进行划分，生成子字符序列，每一个Linkedlist的首元素即list[0]中存储的为原字符序列，而从
             1开始即为原序列拆分之后得到的字符单元.
             ---> 注意，这里如果使用HashMap作为二级存储的话，Key值直接放置String类型原串，Value放置由原串分析得到的字符单元将会很好的解决!
          ③ 针对于HashMap之中已经存在的变量，只需要在其后的list之中添加变量即可.
    3、如何实现状态之间的转换为关键问题，这里不妨创建一个状态类
        -> 使用.状态分析法，可以将改变.位置之后的String数组合并起来
        -> 这里为了方便状态查询，不妨使用一个HashMap来存储字符串对应的状态值: 如：HashMap<String,State>作为查询
        -> 针对于一个状态的创建，要执行如下两步
            ① 根据hashMap中的产生式，将本产生式右侧的.右侧的语法变量进行替代处理
            ② 根据所有输入的可能情况处理在读取输入字符之后转化为的状态
        -> 注意！根据分析可知I0状态与其他状态不同，在I0状态下要手动向开始符号所产生的语法变量前添加.
                而之后的状态就是在读取到某个字符之后，将读入的字符与.的位置进行互换
        -> 对于语法变量和终结符号：
            没有在hashMap的key位置上出现的，即通过hashMap调用get方法获取不到的即为终结符号
    4、状态转换图的构建是难上加南的问题，首先必须解决如何存储的问题
        HashMap<entry<State,String>,state>  -> 不妨采取HashMap这种数据结构用于存储
    5、这里又创建了一个链表用于处理在分析的过程之中产生的新的状态
       -> 当这个新的状态链表中的元素个数为零的时候即为分析结束的时候
       -> 对一个状态进行分析的时候，仍然使用正则表达式
       -> 并且建立起来一个关于可能输入的字符及读取输入之后字符串变化的HashMap
    6、针对于id的识别问题，需要一个解决方案
       -> 需要在状态转换的时候加以分析 --> LR(1) ?
       -> 在针对于关键字的匹配分析部分（位于状态转换方法之中）-> 针对于不同的语法要作出对应的修改
       -> 在.交换位置部分也需要进行修改

       -> 不妨采取编码形式，将所有的长度大于2的字符串单元都给予一个编码，通过编码实现优化处理
          -> 比如id的代称为d
    7、对于状态转换的过程之中，在自状态等价项的填充之中，可以将允许规约的项给收集起来!
       -> 这样在建立goto图的时候会方便很多    --> Test01中关于test9的测试
       -> 在去除.的时候一定注意 regStr = "\\." !!!!※
       -> 虽然有些项可以进行规约，但是也要将其加入到Str之中 -> 所属的状态不能变!
    8、在正则匹配的时候发现了一些问题
        由于空格的存在，使得匹配出现了严重的问题!
        T → T. * F   在匹配 "\\.." 的时候会出现将. 匹配成功的情况!
        -> 要上来就把空格 " " 剔除掉
    9、针对于状态转换表的元素添加问题
        -> HashMap<Map.Entry<State,String>,State> stateHashMap = new HashMap<>();
        --> 这种数据结构存在问题!
        -> 修改为HashMap<State,HashMap<String,State>> stateHashMap

    10、现在已经可以正常生成11个状态!   2021.11.11

    11、接下来要解决其中的冲突项 -> 移入规约冲突和规约规约冲突
        -> 针对于冲突的解决，当然可以求一下它的first集进而推导出follow集
        -> 接下来根据follow集构建SLR(1)分析表
        -> 还需要考虑如何将语法分析和语义处理相结合

    12、在这里，我首先以表达式文法进行了测试，确实可以成功生成所有的状态及转换关系
        -> 但是需要对转换关系进行进一步的处理 --> 生成状态转换表
        -> 不妨先尝试一下将所有的移入规约冲突项全部筛出   --> 这样代码的普遍性会变得很差!
        -> 还需要对于关键字的单字符编码进行完善


    13、还是老老实实算一下first集、follow集...
        (1) first: 为其首符号集
           -> 注意，这里在所有的产生式中都不包含有ε，故无需考虑ε的影响
           -> 终结符号的first集合都不需要求出
           -> 求解思路
            --> 首先判断产生式首字符是否为终结符号，若为终结符号，则将其加入到first集之中;
                若是语法变量，则将该语法变量的first集加入到该符号的first集合之中

        (2) 针对于first集求解的一些思考
           -> 在求解first(E)的时候，根据产生式需要首先计算出来first(F)的值，但是此时还没有到计算first(F)的时候
           -> 这里不妨借用中间代码生成部分的回填技术
            --> 首先创建一个回填列表，中间包含着first集的一些包含信息
            --> 接下来进行first集(A)计算，一旦涉及到包含另一个first集(B)
              -> 首先在first集列表之中查询是否存在该语法变量的first集记录
                  -> 若存在着该记录，就在回填列表中查询该记录是否有着其他等待回填的first集
                        -> 若存在待回填的记录(C) --> 将(B)记录加入到(A)的待回填列表之中，等待B自身完成回填
                        -> 若不存在待回填的记录  --> 将(B)的first集中的所有元素加入到(A)之中
                            -> 在回填完成之后，查询(A)是否还有等待回填的元素，若无
                                --> 则遍历整个待回填的列表，将(A)的first集加入到所有含有(A)的记录中的first集之中
                            -> 若仍有待回填的其他first集
                                --> 继续等待回填
                  -> 倘若不存在该记录，也要将(B)记录加入到(A)的待回填列表之中，等待B自身完成first集的创建
            --> 倘若为终结符号（非语法变量），则将其直接加入到(A)的first集之中
        附：由于first集的特殊性质，在不断回填的过程之中可能出现重复添加的情况，这里不妨更换一种更好的数据结构
            -> 采取HashSet的格式进行存储 [保证不会出现重复的情况]
            --> 注意存在的左递归的问题!!!  -->会陷入死循环之中！

        (3) follow集的求解
            分析:
                ① first集可以根据产生式很容易地生成出来，follow集就需要考虑更多的格式问题
                ② follow集首先从文法的开始符号出发，首先将$加入其中     --> 这就意味着在词法分析生成Token的时候需要在末尾位置加上$
                ③ 需要对所有产生式的右部进行结构分析！
            思路:
                [1] 首先对文法的开始符号求解 -> 扫描所有的产生式，得到其follow集
                [2] 根据文法的开始符号的产生式，依次产生其他语法变量的follow集

        (4) 针对于follow集求解的一些思考
           [1] 推导方案
           -> 首选从文法的开始符号推导
                -> 将$加入到开始符号的follow集之中 --> 扫描所有的产生式，检索是否还有文法开始符号存在的产生式
                  -> 接下来将开始符号的follow集加入到followMap之中，等待被其他符号使用
                    -> 在synVar中遍历文法开始符号所对应的表达式
                        存在着如下两种情况
                        -> 单独一个文法符号 --> follow(E) = follow(P)
                        -> 为一个复杂式子
                            -> 首先分析一下其中包含的文法变量有哪些 ->　保存在templist之中 -> 若产生式中全部为终极符号，停止推导
                            -> 分析语法变量
                                -> 若语法变量与产生式左侧的语法变量相同       -> 停止推导
                                -> 若不同
                                    -> 若位于产生式最末端 -> follow(E) = follow(P)
                                    -> 若位于产生式的中间 -> 观察文法得知，不存在两个语法变量紧挨着的情况
                                        -> 位于产生式中的语法变量的后面只能是终结符号
                                            -> 将终结符号加入到其follow集中即可
           -> 此时才发现无需first集,寄了!


           [2] 推导使用的数据结构
            -> HashMap<String,HashSet<String>> followMap;   //用于存储推导出来的follow集
            -> LinkedList<String> tempList;     //针对于一个语法变量(产生式)所涉及到的所有语法变量的存储链表
                -> 不妨将其升级为HashSet<String>   -> 存储每一次推导得到的语法变量
                                                 -> 进而针对于语法变量的产生式进行分析
                                                 -> 当该HashSet中元素个数为零的时候即为推导结束之时!
                -> HashSet无法取出元素 -->　故仅仅将其当做判断是否分析过该元素
                   LinkedList -> 记录

            [3] 在求解follow集的时候存在着一个致命的问题，就是我们无法保证在将follow(E)加入到follow(T)中的时候，
                保证follow(E)在后续的过程之中不会变化!
                -> 解决这个问题可以采用和求解first集一样的操作，使用待回填的方案进行处理 -> 求出first集没用上已经很炸裂了!
                -> 不妨采取一个硬方法，直接遍历所有的表达式进行求解! 晕
                -> 不妨采用一种更优化的方式进行求解
                    -> 若follow(E)被加入到follow(T)之中，则开辟一个链表，记录follow(E)被加入到follow(T)之中,
                       而follow(T)被加入到follow(F)之中；
                       若follow(E)被改变[被加入了新的元素],则修改follow(E)加入到的所有follow集之中，且由于follow(T)被改变，
                       因此follow(F)也应当被更新!
                    -> 当然也可以针对 E 单独处理，只不过兼容性没有这么高而已
                    -> 为了更好的通配性，干就完了!
                        -> 这里使用LinkedList在加入之前使用contains()判断一下即可解决重复加入的问题

    14、目前已经可以将语法转换图、first集、follow集生成    2021-11-13 22:53
      (1) 接下来如何构建Action表和GoTo表是关键所在
        -> 状态已经可以得到，应当在文法分析阶段将所有的终结符号保存下来!   -> foreach+if即可解决
      (2) 生成转换表 -> 开辟数组存储?
        -> 直接使用array+HashMap存储?
        -> 创建一个ArrayList用于存储状态信息，其中每一个元素为一个HashMap，用于存储转换信息
            -> 比如在ArrayList[0]的位置中有一项Entry为(id,s5)
                -> 表示在状态I0阶段，读取到id之后转移到I5状态
        -> 当然不要忘记在终极符号列表之中加入$
        -> 对应的在词法分析Token中也要加入$

        -> 使用array存储并不能得到很多有效信息!
            -> 不妨使用HashMap进行存储！ --> 但是采取Hash之后线性结构会被打破!
            -> 使用get来获取
            HashMap<State,HashMap<String,State>> actGoToTable = new HashMap<>();

    15、actGoToTable已经可以搭建起来，但是正确性暂时未知,如何测试一下?
      (1) 输入一串字符串进行规约测试，观察是否可以得到文法的开始符号，若下一个ToKen为$，则表示语法校验成功!
      (2) 这需要将语法分析和词法分析结合起来，而语法分析和语义处理部分最好也要结合起来，因此不妨这里先试探性分析
          语义处理，将三者结合起来进行处理
      (3) 由于在语法分析阶段对于关键字进行了编码处理，因此对应的词法分析过程之中，关键字的Token也要对应进行处理
      (4) 针对冲突的解决了没有? -->  未解决!
          -> 必须将产生的follow集用上!
          -> 如何查找产生冲突的位置?
          -> 如何将产生冲突的项修改?
          -> 有一种方式是针对于每一个产生移入规约冲突的地方进行分析，根据follow集判断
          -> 还有一种方式就是先暂时不管冲突，等到对输入的数据将要执行规约操作的时候，对其下一个元素进行判断，若处于
             其follow集中时，则不对其进行规约操作

    16、分析过程
      (1) 创建两个堆栈用于存储状态及符号
      (2) 将初始状态(I0)加入到状态栈之中，并将$压入符号栈
      (3) 接下来读取输入的Token -> 在actionGoTo表中寻找当前状态对应的输入情况
          -> 注意到actionGoTo表之中key存储的是状态(State类型)，其中Str属性中记载着该状态对应的所有项
          -> 根据读入的Token值的Type来判断输入的终极符号类型  --> 这里需要对其进行编码处理
                                                        --> 使得输入的Type类型与文法中的类型一致
          -> 分析两个栈中状态栈目前存储的状态及符号栈中的内容
          -> 根据目前栈顶的状态及输入的符号分析状态转换，并将转换之后的状态压入状态栈之中
          -> 接下来判断符号栈中的内容是否为可规约项 -> 若是可规约项，则判断下一个输入的字符是否为$,
                                                    -> 若不是,判断其规约之后的状态对应的文法符号的follow集中是否包含了该项
                                                        -> 若不包含，则进行规约操作
                                                        -> 若包含，则进行移入操作
                                              -> 若为不可规约项,则执行移入操作


    17、(1) 针对于Token的编码 -> 双字节运算符目前只能处理==  -> 仍有待扩展的区间
        (2) int float等定义关键字不会在其中出现，因此无需编码
        (3) 若为终结符号，其value值就等于name值
            ======================================
            以上，词法分析编码阶段已经完成
            接下来对栈的结构进行实现
        (4)


    18、在语法分析过程之中分析是否存在规约项的时候，并不是一上来就拿符号栈中所有的内容进行匹配，
        而是从栈顶依次向下匹配!寻找符合的字符串!

    19、表达式简单文法校验并不会将;加入其中!


    20、AnalysisInput中存在对于：
        //针对于if - else的特殊处理 ->  ※    --> 此处理方案无效!?
        -> if(find.equals("S→f(C)S.") && word.getValue().equals("e")) --> 有效!


    21、由于词法分析采取正则处理的方式，因此会比普通的程序拥有更好的兼容性 -> 同时也可能出现一些相关的问题!
        -> 正是由于正则的高兼容性所以导致很有可能将一个错误输入矫正为一个类似正确的输入!
         --> 比如输入 a = a b 的时候，正则处理为 a = ab
            -> 程序会认为存在一个名为ab的变量，进而将其视为正确语句执行分析，但是确实不正确的!
        -> 由于大范围内使用正则，因此不对其进行修改
        -> 受限于语法的格式，也不会出现很多复杂的内容，因此在语义分析的时候加入错误处理程序
        -> 词法分析采取LR(1)的方式进行处理


    22、语义处理如何进行?
        -> 要以三地址代码的形式还是在语法分析的过程之中使用受控的副作用执行?


    23、可不可以做一个独立于语法分析之外的单独的词法分析程序?
        -> 语法分析程序仅仅被用于校验输入的程序是否符合语法规则
        -> 若是采取在语法分析的同时通过加入一些属性及受控的副作用进行语义处理
        -> 会使得语义处理变得较为复杂!

        -> 如何实现独立处理?
        语义处理的目的是什么?

    26、翻译的任务:
      (1) 语义分析和正确性检查，若正确，则翻译为中间代码或者目标代码
      (2) 基本思想是语法结构具有规定的语义信息，根据翻译的需要设置文法符号的属性


    27、其中一种典型的处理方法就是针对于每一个产生式都编制一个语义子程序，每当一个产生式获得匹配
        的时候，调用相应的语义子程序实现语义检查与翻译

        E -> E1 + T     E.val = E1.val + T.val  [当然在执行该操作之前需要有一些检查]

    28、语法制导定义 -> 属性和文法符号相关联、规则和产生式相关联

    --> 倘若采取针对语法变量赋属性值的方法执行，就要将语法分析所用的数据结构进行改变!
      --> 与此同时，词法分析得到的Token值中的value存储的内容也要随之改变!
        --> 同时需要定义一种运算方法

    --> 倘若真的以这种方式进行实现，需要首先定义一个类作为语法变量的基本单元，
        其中定义了语法变量的表面字符值(如F等)，同时还要定义语法变量的另一些属性(如综合属性与继承属性)
        --> 并且还要定义两个对象之间的运算操作及运算得到的结果将如何进行处理的问题!...

    --> 还有一种解决方案是独立于语法分析结果之外的分析方法
        -> 即倘若语法分析可以正常通过，这就意味着在语法上暂时没有发现问题，也就意味着我们可以采取一些固定的模式
           去匹配处理输入的字符等。
        -> 语义处理及中间代码生成部分无非就是将输入的符号处理为串行执行的代码去执行，
           好像存在套路可以利用!

           -> 不妨给出一些时间尝试一下，实在不行了再去修改数据结构 --> 可以采取和求解first集一样的操作(回填!)


    29、    经过一晚上的思考，觉得修改语法分析中的数据结构的方式确实可行，且可以在分析的过程之中通过受控的副作用等将对应
        的属性值之间的赋值关系进行解决。
            -> 想法如下：
            --> 首先创建一个存储文法符号的类(为了保证一致性这里为终结符号也以类的形式进行保存)
            --> 类内部存有一些私有属性，其中最重要的是String类型的当前符号的name
            --> 另外还有在处理在语义处理的过程之中需要存储的值(比如综合属性val,继承属性inh,终结符号的属性lexval等)
                还有在生成中间代码的过程之中使用到的属性(如addr,code属性等)   -> 当然在处理运算语句的时候需要进行类型校验等
                -> 针对于控制流语句的翻译过程之中使用到的属性(true,false等)
                -> 针对于布尔表达式的回填翻译中使用到的属性(truelist,falselist等)
                   还有一些辅助函数: Makelist(i),Merge(p1,p2),BackPatch(p,i)

            -> 修改注意事项
                -> 在文法读入的时候就要进行修改!   -->  处理文法的时候依然可以采取原来的方式，及以String类型进行处理
                -> 但是在处理输入的字符的时候，针对于Token的每一个value值，都需要创建一个对象用于存储 -> 将value赋给name属性
                   -> 这就意味着需要将存储输入字符的栈结构进行改变 --> 改为存储该类对象的栈
                   -> 同时在进行移入规约运算的时候也需要调用类之间的运算方法 --> 对象之间name的拼接等
                   -> 在规约的时候通过一些受控的副作用对属性进行进行处理



            -> 针对于声明语句的处理目前无需考虑
            -> 针对于赋值语句的处理:
                一般来说，在规约的时候将该三地址代码生成出来
                    -> 这就意味着语法变量需要存储有一定的语义信息，并针对于不同的产生式有不同的三地址代码生成方式

            -> 第一阶段使用Symbol类对象代替String测试成功!
            -> 接下来要引入符号变量等
            -> 还要在规约的时候，根据对应的产生式不同决定产生何种类型的三地址代码
            -> 这就意味着需要创建一个存储三地址代码的数据结构 -> 使用ArrayList即可


            -> 首先在取出输入队列中的元素的时候，需要判断一下其类型
                -> 若为id类型或者为数字类型 --> 需要将name属性赋予对应的code
                -> 接下来在F →　d 中存在的第一次规约
                 --> 有一种想法是可不可以将三地址代码的生成重语法分析的过程之中抽取出来，将符号栈及表达式传入进去，
                     生成对应的三地址代码之后返回主程序之中!
                     还必须有要规约为的符号! 传入进去 ※
            -> 针对于读入的Token队列，还需要另外开辟一个栈结构去存储它们!  --> 否则就会造成数据丢失的情况!
                -> 每移入一个Token，都要将其加入到该栈中
                -> 同时维护一个全局变量用于产生三地址代码的序号label

            -> 目前为止赋值语句及声明语句的处理已经全部完成!

            -> 接下来对控制流语句进行解析
            --> 若不采取回填的技术，是否可以更加简化?

            -> 首先针对布尔表达式进行处理

            -> 针对每一个规约项目，不妨使用其value值取记载规约之后的三地址代码,以便于在控制流语句之中执行跳转
            -> 针对于一个规约项目，都会有一个规约起点，value值就是负责记录该规约起点的字符串
               --> 分析之后发现，该式由加减乘除运算得到!
                -> 首先分析乘除运算，当没有乘除运算时记录加减运算

            -> 以上方式确实可以有效，但是会存在执行语句在判断语句之前的情况，虽然可以跳转回去!
                -> 如何解决这个问题?
                -> 在执行布尔表达式运算的时候，将下一条代码位置空出以便于跳转!
                    -> 等到执行到if语句的时候进行回填!
                    -> 接下来在if语句被添加到里面之前在填充一个跳转语句!


            -> 解决掉一个简单的if语句!
            -> 接下来处理if-else语句!
            -> while语句已经被处理!


            -> 但是现在文法的产生方式及规约方式并不如我所愿 --> 不妨尝试修改一下文法
            -> S → d = E ; S
                --> 该产生式是为了解决出现多条语句的时候的规约问题而引入的，但是却导致很多产生式都没有按照规定的
                    方式执行规约
                --> 增加一个判断，若是跟在if后面，则增加一个goto语句去执行;后面的S!
                --> 将这一条跳转语句加入S的属性之中 --> 使用Key进行存储

                -> 执行S → f ( C ) S规约的时候，若key不为null -> 添加语句!  ---> 成功解决!

            -> 目前已经全部实现单个if、单个if-else、单个while的翻译过程（赋值语句不限）
            -> 多条语句的合并翻译过程暂未实现!    --> 由于定义域的划分等问题造成一定的困难
            -> 由于查询符号表的功能暂未引入，因此此时多位字符的赋值存在着一定的问题!   --> 词法分析需要更加完善


int a;
int b;

a = 0;
b = 2;

a = a + 1;
b = b - 1;

if ( a == b )
    b = a * b;
else
    a = b * a;


















