一、词法分析
    1、目前为止，词法分析的内容确实都快忘了！！这里的想法是先将输入的语句分隔开处理为二元式的格式
    2、
    int a;
    int b;
    int c;
    a = 2;
    b = 1;              //多位数赋值?
    if ( a > b )
    c = a + b;
    else
    c = a - b;
    不妨对以上语句进行分析发现，倘若使用RE对原始字符串进行分割可能会好一些
    3、思路是
        (1)首先将从文件中读取到的字符串以空格为标识符进行分割 -> 预处理阶段
        (2)接下来对得到的每一个字符串转换为byte[]进行处理
        (3)创造一个Word类来存储输入的字符，定义一些属性与变量
        (4)不妨使用LinkedList作为存储工具，将得到的所有字符按照一定的顺序构建出对应的链表(循环链表较为合适!)

    附：一些思考
    ① 由于引入正则匹配的形式，这也就意味着可以直接对一些类型定义(关键字)进行匹配
    ② 需要考虑的一些问题
        [1] 多位数为变量赋值的问题                             √
        [2] 变量的多位数定义问题                               √
        [3] 关于使用链表存储的问题，发现下标Index不存在也可以!
        [4] 注意！关键字中出现了float，这也就意味着可以定义小数，因此需要对'.'进行处理!
        [5] 这里不妨强制要求运算符左右都留有空格！ (dog^)
        [6] 未定义变量就直接使用的问题 -> 这里必须先定义变量才行，否则多字符变量会被拆解为单字符变量!
                                  ->  定义之后就可以通过查表的形式进行辨别
                                  -> 即在regWord中添加在符号表(想法是以HashMap形式实现)中查询
    4、分析语句中出现的各种符号的类型

    5、接下来对符号表进行构建
        -> 符号表中存储有变量(标识符)和常量(数字常数和字符常数)
            -> 这里需要做的就是将标识符实例化出来(想法是构建一个类),存放入HashMap中作为符号表
        -> 针对于这个类的构建: ① 需要有int、float私有属性，这里建议使用包装类实现         -> 再加上一个Word类作为私有属性(存储类型及种别等)
                            ② 若扫描到为关键字，则进入符号表的构建状态，创建类加入符号表中
                            ③ 针对于这些变量的定义，基本上为keyWord + letter + ; 组成
                            ④ 扫描词法分析初步形成的序列即可摘出这些定义

    6、遇到的问题:
      (1) == 并不能匹配!     正则匹配要接收返回值!
      (2) 针对重复定义问题: 使用IdentityHashMap作为符号表的时候会出现重复的情况，因为IdentityHashMap的key判断标准为若两者是不同的对象，
          哪怕使用String.equal()得到的结果为true，也可以被加入到其中.


二、语法分析
    1、难度断崖式增长!
    2、必须自动生成
       -> 首先对于从文件中读取的字符串，以换行符(\r\n)为界限进行划分为子字符串序列
       -> 对产生式进行分析 --> S → id = E;
       -> ① 以 ' → ' 为分隔符进行划分
          ② 将右部得到的语法变量加入到一个HashMap之中，Key值即为String类型的字符串，而Value值为由Key可以生成的字符序列(这里使用LinkedList存储)
             接下来还必须对得到的序列进行分析，以 ' ' 为界限进行划分，生成子字符序列，每一个Linkedlist的首元素即list[0]中存储的为原字符序列，而从
             1开始即为原序列拆分之后得到的字符单元.
             ---> 注意，这里如果使用HashMap作为二级存储的话，Key值直接放置String类型原串，Value放置由原串分析得到的字符单元将会很好的解决!
          ③ 针对于HashMap之中已经存在的变量，只需要在其后的list之中添加变量即可.
    3、如何实现状态之间的转换为关键问题，这里不妨创建一个状态类
        -> 使用.状态分析法，可以将改变.位置之后的String数组合并起来
        -> 这里为了方便状态查询，不妨使用一个HashMap来存储字符串对应的状态值: 如：HashMap<String,State>作为查询
        -> 针对于一个状态的创建，要执行如下两步
            ① 根据hashMap中的产生式，将本产生式右侧的.右侧的语法变量进行替代处理
            ② 根据所有输入的可能情况处理在读取输入字符之后转化为的状态
        -> 注意！根据分析可知I0状态与其他状态不同，在I0状态下要手动向开始符号所产生的语法变量前添加.
                而之后的状态就是在读取到某个字符之后，将读入的字符与.的位置进行互换
        -> 对于语法变量和终结符号：
            没有在hashMap的key位置上出现的，即通过hashMap调用get方法获取不到的即为终结符号
    4、状态转换图的构建是难上加南的问题，首先必须解决如何存储的问题
        HashMap<entry<State,String>,state>  -> 不妨采取HashMap这种数据结构用于存储
    5、这里又创建了一个链表用于处理在分析的过程之中产生的新的状态
       -> 当这个新的状态链表中的元素个数为零的时候即为分析结束的时候
       -> 对一个状态进行分析的时候，仍然使用正则表达式
       -> 并且建立起来一个关于可能输入的字符及读取输入之后字符串变化的HashMap