一、词法分析
    1、目前为止，词法分析的内容确实都快忘了！！这里的想法是先将输入的语句分隔开处理为二元式的格式
    2、
    int a;
    int b;
    int c;
    a = 2;
    b = 1;              //多位数赋值?
    if ( a > b )
    c = a + b;
    else
    c = a - b;
    不妨对以上语句进行分析发现，倘若使用RE对原始字符串进行分割可能会好一些
    3、思路是
        (1)首先将从文件中读取到的字符串以空格为标识符进行分割 -> 预处理阶段
        (2)接下来对得到的每一个字符串转换为byte[]进行处理
        (3)创造一个Word类来存储输入的字符，定义一些属性与变量
        (4)不妨使用LinkedList作为存储工具，将得到的所有字符按照一定的顺序构建出对应的链表(循环链表较为合适!)

    附：一些思考
    ① 由于引入正则匹配的形式，这也就意味着可以直接对一些类型定义(关键字)进行匹配
    ② 需要考虑的一些问题
        [1] 多位数为变量赋值的问题                             √
        [2] 变量的多位数定义问题                               √
        [3] 关于使用链表存储的问题，发现下标Index不存在也可以!
        [4] 注意！关键字中出现了float，这也就意味着可以定义小数，因此需要对'.'进行处理!
        [5] 这里不妨强制要求运算符左右都留有空格！ (dog^)
        [6] 未定义变量就直接使用的问题 -> 这里必须先定义变量才行，否则多字符变量会被拆解为单字符变量!
                                  ->  定义之后就可以通过查表的形式进行辨别
                                  -> 即在regWord中添加在符号表(想法是以HashMap形式实现)中查询
    4、分析语句中出现的各种符号的类型

    5、接下来对符号表进行构建
        -> 符号表中存储有变量(标识符)和常量(数字常数和字符常数)
            -> 这里需要做的就是将标识符实例化出来(想法是构建一个类),存放入HashMap中作为符号表
        -> 针对于这个类的构建: ① 需要有int、float私有属性，这里建议使用包装类实现         -> 再加上一个Word类作为私有属性(存储类型及种别等)
                            ② 若扫描到为关键字，则进入符号表的构建状态，创建类加入符号表中
                            ③ 针对于这些变量的定义，基本上为keyWord + letter + ; 组成
                            ④ 扫描词法分析初步形成的序列即可摘出这些定义

    6、遇到的问题:
      (1) == 并不能匹配!     正则匹配要接收返回值!
      (2) 针对重复定义问题: 使用IdentityHashMap作为符号表的时候会出现重复的情况，因为IdentityHashMap的key判断标准为若两者是不同的对象，
          哪怕使用String.equal()得到的结果为true，也可以被加入到其中.


二、语法分析
    1、难度断崖式增长!
    2、必须自动生成
       -> 首先对于从文件中读取的字符串，以换行符(\r\n)为界限进行划分为子字符串序列
       -> 对产生式进行分析 --> S → id = E;
       -> ① 以 ' → ' 为分隔符进行划分
          ② 将右部得到的语法变量加入到一个HashMap之中，Key值即为String类型的字符串，而Value值为由Key可以生成的字符序列(这里使用LinkedList存储)
             接下来还必须对得到的序列进行分析，以 ' ' 为界限进行划分，生成子字符序列，每一个Linkedlist的首元素即list[0]中存储的为原字符序列，而从
             1开始即为原序列拆分之后得到的字符单元.
             ---> 注意，这里如果使用HashMap作为二级存储的话，Key值直接放置String类型原串，Value放置由原串分析得到的字符单元将会很好的解决!
          ③ 针对于HashMap之中已经存在的变量，只需要在其后的list之中添加变量即可.
    3、如何实现状态之间的转换为关键问题，这里不妨创建一个状态类
        -> 使用.状态分析法，可以将改变.位置之后的String数组合并起来
        -> 这里为了方便状态查询，不妨使用一个HashMap来存储字符串对应的状态值: 如：HashMap<String,State>作为查询
        -> 针对于一个状态的创建，要执行如下两步
            ① 根据hashMap中的产生式，将本产生式右侧的.右侧的语法变量进行替代处理
            ② 根据所有输入的可能情况处理在读取输入字符之后转化为的状态
        -> 注意！根据分析可知I0状态与其他状态不同，在I0状态下要手动向开始符号所产生的语法变量前添加.
                而之后的状态就是在读取到某个字符之后，将读入的字符与.的位置进行互换
        -> 对于语法变量和终结符号：
            没有在hashMap的key位置上出现的，即通过hashMap调用get方法获取不到的即为终结符号
    4、状态转换图的构建是难上加南的问题，首先必须解决如何存储的问题
        HashMap<entry<State,String>,state>  -> 不妨采取HashMap这种数据结构用于存储
    5、这里又创建了一个链表用于处理在分析的过程之中产生的新的状态
       -> 当这个新的状态链表中的元素个数为零的时候即为分析结束的时候
       -> 对一个状态进行分析的时候，仍然使用正则表达式
       -> 并且建立起来一个关于可能输入的字符及读取输入之后字符串变化的HashMap
    6、针对于id的识别问题，需要一个解决方案
       -> 需要在状态转换的时候加以分析 --> LR(1) ?
       -> 在针对于关键字的匹配分析部分（位于状态转换方法之中）-> 针对于不同的语法要作出对应的修改
       -> 在.交换位置部分也需要进行修改

       -> 不妨采取编码形式，将所有的长度大于2的字符串单元都给予一个编码，通过编码实现优化处理
          -> 比如id的代称为d
    7、对于状态转换的过程之中，在自状态等价项的填充之中，可以将允许规约的项给收集起来!
       -> 这样在建立goto图的时候会方便很多    --> Test01中关于test9的测试
       -> 在去除.的时候一定注意 regStr = "\\." !!!!※
       -> 虽然有些项可以进行规约，但是也要将其加入到Str之中 -> 所属的状态不能变!
    8、在正则匹配的时候发现了一些问题
        由于空格的存在，使得匹配出现了严重的问题!
        T → T. * F   在匹配 "\\.." 的时候会出现将. 匹配成功的情况!
        -> 要上来就把空格 " " 剔除掉
    9、针对于状态转换表的元素添加问题
        -> HashMap<Map.Entry<State,String>,State> stateHashMap = new HashMap<>();
        --> 这种数据结构存在问题!
        -> 修改为HashMap<State,HashMap<String,State>> stateHashMap

    10、现在已经可以正常生成11个状态!   2021.11.11

    11、接下来要解决其中的冲突项 -> 移入规约冲突和规约规约冲突
        -> 针对于冲突的解决，当然可以求一下它的first集进而推导出follow集
        -> 接下来根据follow集构建SLR(1)分析表
        -> 还需要考虑如何将语法分析和语义处理相结合

    12、在这里，我首先以表达式文法进行了测试，确实可以成功生成所有的状态及转换关系
        -> 但是需要对转换关系进行进一步的处理 --> 生成状态转换表
        -> 不妨先尝试一下将所有的移入规约冲突项全部筛出   --> 这样代码的普遍性会变得很差!
        -> 还需要对于关键字的单字符编码进行完善


    13、还是老老实实算一下first集、follow集...
        (1) first: 为其首符号集
           -> 注意，这里在所有的产生式中都不包含有ε，故无需考虑ε的影响
           -> 终结符号的first集合都不需要求出
           -> 求解思路
            --> 首先判断产生式首字符是否为终结符号，若为终结符号，则将其加入到first集之中;
                若是语法变量，则将该语法变量的first集加入到该符号的first集合之中

        (2) 针对于first集求解的一些思考
           -> 在求解first(E)的时候，根据产生式需要首先计算出来first(F)的值，但是此时还没有到计算first(F)的时候
           -> 这里不妨借用中间代码生成部分的回填技术
            --> 首先创建一个回填列表，中间包含着first集的一些包含信息
            --> 接下来进行first集(A)计算，一旦涉及到包含另一个first集(B)
              -> 首先在first集列表之中查询是否存在该语法变量的first集记录
                  -> 若存在着该记录，就在回填列表中查询该记录是否有着其他等待回填的first集
                        -> 若存在待回填的记录(C) --> 将(B)记录加入到(A)的待回填列表之中，等待B自身完成回填
                        -> 若不存在待回填的记录  --> 将(B)的first集中的所有元素加入到(A)之中
                            -> 在回填完成之后，查询(A)是否还有等待回填的元素，若无
                                --> 则遍历整个待回填的列表，将(A)的first集加入到所有含有(A)的记录中的first集之中
                            -> 若仍有待回填的其他first集
                                --> 继续等待回填
                  -> 倘若不存在该记录，也要将(B)记录加入到(A)的待回填列表之中，等待B自身完成first集的创建
            --> 倘若为终结符号（非语法变量），则将其直接加入到(A)的first集之中
        附：由于first集的特殊性质，在不断回填的过程之中可能出现重复添加的情况，这里不妨更换一种更好的数据结构
            -> 采取HashSet的格式进行存储 [保证不会出现重复的情况]
            --> 注意存在的左递归的问题!!!  -->会陷入死循环之中！

        (3) follow集的求解
            分析:
                ① first集可以根据产生式很容易地生成出来，follow集就需要考虑更多的格式问题
                ② follow集首先从文法的开始符号出发，首先将$加入其中     --> 这就意味着在词法分析生成Token的时候需要在末尾位置加上$
                ③ 需要对所有产生式的右部进行结构分析！
            思路:
                [1] 首先对文法的开始符号求解 -> 扫描所有的产生式，得到其follow集
                [2] 根据文法的开始符号的产生式，依次产生其他语法变量的follow集

        (4) 针对于follow集求解的一些思考
           [1] 推导方案
           -> 首选从文法的开始符号推导
                -> 将$加入到开始符号的follow集之中 --> 扫描所有的产生式，检索是否还有文法开始符号存在的产生式
                  -> 接下来将开始符号的follow集加入到followMap之中，等待被其他符号使用
                    -> 在synVar中遍历文法开始符号所对应的表达式
                        存在着如下两种情况
                        -> 单独一个文法符号 --> follow(E) = follow(P)
                        -> 为一个复杂式子
                            -> 首先分析一下其中包含的文法变量有哪些 ->　保存在templist之中 -> 若产生式中全部为终极符号，停止推导
                            -> 分析语法变量
                                -> 若语法变量与产生式左侧的语法变量相同       -> 停止推导
                                -> 若不同
                                    -> 若位于产生式最末端 -> follow(E) = follow(P)
                                    -> 若位于产生式的中间 -> 观察文法得知，不存在两个语法变量紧挨着的情况
                                        -> 位于产生式中的语法变量的后面只能是终结符号
                                            -> 将终结符号加入到其follow集中即可
           -> 此时才发现无需first集,寄了!


           [2] 推导使用的数据结构
            -> HashMap<String,HashSet<String>> followMap;   //用于存储推导出来的follow集
            -> LinkedList<String> tempList;     //针对于一个语法变量(产生式)所涉及到的所有语法变量的存储链表
                -> 不妨将其升级为HashSet<String>   -> 存储每一次推导得到的语法变量
                                                 -> 进而针对于语法变量的产生式进行分析
                                                 -> 当该HashSet中元素个数为零的时候即为推导结束之时!
                -> HashSet无法取出元素 -->　故仅仅将其当做判断是否分析过该元素
                   LinkedList -> 记录

            [3] 在求解follow集的时候存在着一个致命的问题，就是我们无法保证在将follow(E)加入到follow(T)中的时候，
                保证follow(E)在后续的过程之中不会变化!
                -> 解决这个问题可以采用和求解first集一样的操作，使用待回填的方案进行处理 -> 求出first集没用上已经很炸裂了!
                -> 不妨采取一个硬方法，直接遍历所有的表达式进行求解! 晕
                -> 不妨采用一种更优化的方式进行求解
                    -> 若follow(E)被加入到follow(T)之中，则开辟一个链表，记录follow(E)被加入到follow(T)之中,
                       而follow(T)被加入到follow(F)之中；
                       若follow(E)被改变[被加入了新的元素],则修改follow(E)加入到的所有follow集之中，且由于follow(T)被改变，
                       因此follow(F)也应当被更新!
                    -> 当然也可以针对 E 单独处理，只不过兼容性没有这么高而已
                    -> 为了更好的通配性，干就完了!
                        -> 这里使用LinkedList在加入之前使用contains()判断一下即可解决重复加入的问题

    14、目前已经可以将语法转换图、first集、follow集生成    2021-11-13 22:53
      (1) 接下来如何构建Action表和GoTo表是关键所在
        -> 状态已经可以得到，应当在文法分析阶段将所有的终结符号保存下来!   -> foreach+if即可解决
      (2) 生成转换表 -> 开辟数组存储?
        -> 直接使用array+HashMap存储?
        -> 创建一个ArrayList用于存储状态信息，其中每一个元素为一个HashMap，用于存储转换信息
            -> 比如在ArrayList[0]的位置中有一项Entry为(id,s5)
                -> 表示在状态I0阶段，读取到id之后转移到I5状态
        -> 当然不要忘记在终极符号列表之中加入$
        -> 对应的在词法分析Token中也要加入$

        -> 使用array存储并不能得到很多有效信息!
            -> 不妨使用HashMap进行存储！ --> 但是采取Hash之后线性结构会被打破!
            -> 使用get来获取
            HashMap<State,HashMap<String,State>> actGoToTable = new HashMap<>();

    15、actGoToTable已经可以搭建起来，但是正确性暂时未知,如何测试一下?
      (1) 输入一串字符串进行规约测试，观察是否可以得到文法的开始符号，若下一个ToKen为$，则表示语法校验成功!
      (2) 这需要将语法分析和词法分析结合起来，而语法分析和语义处理部分最好也要结合起来，因此不妨这里先试探性分析
          语义处理，将三者结合起来进行处理
      (3) 由于在语法分析阶段对于关键字进行了编码处理，因此对应的词法分析过程之中，关键字的Token也要对应进行处理
      (4) 针对冲突的解决了没有? -->  未解决!
          -> 必须将产生的follow集用上!
          -> 如何查找产生冲突的位置?
          -> 如何将产生冲突的项修改?
          -> 有一种方式是针对于每一个产生移入规约冲突的地方进行分析，根据follow集判断
          -> 还有一种方式就是先暂时不管冲突，等到对输入的数据将要执行规约操作的时候，对其下一个元素进行判断，若处于
             其follow集中时，则不对其进行规约操作

    16、分析过程
      (1) 创建两个堆栈用于存储状态及符号
      (2) 将初始状态(I0)加入到状态栈之中，并将$压入符号栈
      (3) 接下来读取输入的Token -> 在actionGoTo表中寻找当前状态对应的输入情况
          -> 注意到actionGoTo表之中key存储的是状态(State类型)，其中Str属性中记载着该状态对应的所有项
          -> 根据读入的Token值的Type来判断输入的终极符号类型  --> 这里需要对其进行编码处理
                                                        --> 使得输入的Type类型与文法中的类型一致
          -> 分析两个栈中状态栈目前存储的状态及符号栈中的内容
          -> 根据目前栈顶的状态及输入的符号分析状态转换，并将转换之后的状态压入状态栈之中
          -> 接下来判断符号栈中的内容是否为可规约项 -> 若是可规约项，则判断下一个输入的字符是否为$,
                                                    -> 若不是,判断其规约之后的状态对应的文法符号的follow集中是否包含了该项
                                                        -> 若不包含，则进行规约操作
                                                        -> 若包含，则进行移入操作
                                              -> 若为不可规约项,则执行移入操作


    17、(1) 针对于Token的编码 -> 双字节运算符目前只能处理==  -> 仍有待扩展的区间
        (2) int float等定义关键字不会在其中出现，因此无需编码
        (3) 若为终结符号，其value值就等于name值
            ======================================
            以上，词法分析编码阶段已经完成
            接下来对栈的结构进行实现
        (4)


    18、在语法分析过程之中分析是否存在规约项的时候，并不是一上来就拿符号栈中所有的内容进行匹配，
        而是从栈顶依次向下匹配!寻找符合的字符串!

    19、表达式简单文法校验并不会将;加入其中!


    20、AnalysisInput中存在对于：
        //针对于if - else的特殊处理 ->  ※    --> 此处理方案无效!?
        -> if(find.equals("S→f(C)S.") && word.getValue().equals("e")) --> 有效!


    21、由于词法分析采取正则处理的方式，因此会比普通的程序













